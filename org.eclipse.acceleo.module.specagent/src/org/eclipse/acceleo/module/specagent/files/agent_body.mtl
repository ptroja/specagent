[comment encoding = UTF-8 /]
[module agent_body('http://multirobotsystem/1.0')/]
[import utils/]

[template InputDataBuffers (anAgent : Agent) ]
-- Shared buffer type for holding data of asynchronous writes to the agent
protected SharedInputDataBuffers is
   -- Entry for conditional receive of data from a single buffer
   entry BlockForSingleMessage
     (state : out Agent_[anAgent.name/]_Buffers.input.Data_Type;
      fresh : out fresh_status_t);
   -- Entry for conditional receive of data from a single buffer
   procedure PeekForSingleMessage
     (state   : out Agent_[anAgent.name/]_Buffers.input.Data_Type;
      fresh   : out fresh_status_t;
      arrived : out Boolean);
   -- Procedures for transmitting data to particulars buffers
   [for (buffer : InputBuffer | allInputBuffers(anAgent))]
   procedure Send_[bufferId(buffer)/] (item : in Agent_[anAgent.name/]_Buffers.[inputBufferDataType(buffer)/]);
   [/for] 
private
   -- Internal, protected copy of the data
   buffer_state : Agent_[anAgent.name/]_Buffers.input.Data_Type;
   -- State of the buffers
   fresh_state : fresh_status_t := (others => False);
   -- Flag for speedup check of the buffers status
   -- note: this flag is also required for a Ravenscar profile
   not_empty : Boolean := False;
end SharedInputDataBuffers;

----------------------------
-- SharedInputDataBuffers --
----------------------------

protected body SharedInputDataBuffers is
   procedure PeekForSingleMessage
     (state   : out Agent_[anAgent.name/]_Buffers.input.Data_Type;
      fresh   : out fresh_status_t;
      arrived : out Boolean) is
   begin
      if not_empty then
         -- Pick up data from a single buffer
         [for (buffer : InputBuffer | allInputBuffers(anAgent))
            before ('         if')
            separator ('         elsif')
            after('         end if;\n')
            ] fresh ([bufferId(buffer)/]) then
            state.[inputBufferData(buffer)/]  := buffer_state.[inputBufferData(buffer)/];
            fresh ([bufferId(buffer)/])       := True;
            fresh_state ([bufferId(buffer)/]) := False;
         [/for]

         -- Update the 'empty' flag
         not_empty := False;
         Update_Empty_Flag : for id in buffer_id'Range loop
            if fresh_state (id) then
               not_empty := True;
               exit Update_Empty_Flag;
            end if;
         end loop Update_Empty_Flag;

         arrived := True;
      else
         arrived := False;
      end if;
   end PeekForSingleMessage;

   entry BlockForSingleMessage
     (state : out Agent_[anAgent.name/]_Buffers.input.Data_Type;
      fresh : out fresh_status_t) when not_empty
   is
      arrived : Boolean;
   begin
      PeekForSingleMessage (state, fresh, arrived);
   end BlockForSingleMessage;

   [for (buffer : InputBuffer | allInputBuffers(anAgent))]
   procedure Send_[bufferId(buffer)/]
      (item : in Agent_[anAgent.name/]_Buffers.[inputBufferDataType(buffer)/]) is
   begin
      buffer_state.[inputBufferData(buffer)/] := item;
      fresh_state ([bufferId(buffer)/]) := True;
      not_empty        := True;
   end Send_[bufferId(buffer)/];
   [/for]   

end SharedInputDataBuffers;
[/template]

[template AgentTaskMainBody (anAgent : Agent) ]
task body Main is
   blocking  : Boolean;
   inputData : Agent_[anAgent.name/]_Buffers.input.Data_Type;
   fresh     : fresh_status_t := (others => False);
   arrived   : Boolean;
begin
   --  Note: data buffer should be already initialized
   --  inputData.sensor_X1.X1 := 0;

   [for (aBehavior : Behaviour | behaviours)
      before ('   if')
      separator ('   elsif')
      after('   end if;\n')
   ] (Behavior_[aBehavior.name/].initial_condition (inputData)) then

      blocking := False;

      while (not Behavior_[aBehavior.name/].terminal_condition (inputData)) loop

         if blocking then
            SharedInputDataBuffers.BlockForSingleMessage
              (inputData,
               fresh);
            blocking := False;
         else
            SharedInputDataBuffers.PeekForSingleMessage
              (inputData,
               fresh,
               arrived);

            if arrived then
               blocking := False;
            else
               -- if (...) then f1(state);
               -- elsif (...) then f2(state);
               -- elsif (...) then ...(state);
               -- else blocking := true;
               -- end if;

               -- (1) Check every variant
               -- (2) Call the transition function
               -- (3) mark the condition buffers as used
               [for (function : TransitionFunction | aBehavior.functions)
                  before ('               if')
                  separator ('               elsif')
                  after('               end if;\n')
               ] fresh (X1) then
                  -- Ada.Text_IO.Put_Line("transition_function_1...");
                  fresh (X1) := False;
               [/for]
               --  else
               --  blocking := True;
               --  end if;
            end if;
         end if;
      end loop;
   [/for]
end Main;
[/template]

[template public AgentRCI (anAgent : Agent) ]
[if effector.inputs->notEmpty()]
--  forward RCI of the effector inputs
package body effector is
   [for (aInputBuffer : InputBuffer | effector.inputs)]
   package body [aInputBuffer.name/] is
      use Agent_[anAgent.name/]_Buffers.effector.inputs.[aInputBuffer.name/];
      procedure Send(item : in Data_Type) is
      begin
         SharedInputDataBuffers.Send_[bufferId(aInputBuffer)/](item);
      end Send;
   end [aInputBuffer.name/];
   [/for]
end effector;
[else]
--  there are no RCI to forward for the effector inputs
[/if]   

[if sensors.inputs->notEmpty()]
--  forward RCI of the sensor inputs
package body sensors is
   [for (aSensor : Sensor | sensors->select(inputs->notEmpty()))]
   package body [aSensor.name/] is
      [for (aInputBuffer : InputBuffer | aSensor.inputs)]
      package body [aInputBuffer.name/] is
         use Agent_[anAgent.name/]_Buffers.sensors.[aSensor.name/].inputs.[aInputBuffer.name/];
         procedure Send(item : in Data_Type) is
         begin
            SharedInputDataBuffers.Send_[bufferId(aInputBuffer)/](item);
         end Send;
      end [aInputBuffer.name/];
      [/for]
   end [aSensor.name/];
   [/for]
end sensors;
[else]
--  there are no RCI to forward for the sensor inputs
[/if]

[if transmitters.inputs->notEmpty()]
--  forward RCI of the transmitter inputs
package body transmitters is
   [for (aTransmitter : Transmitter | transmitters->select(inputs->notEmpty()))]
   package body [aTransmitter.name/] is
      [for (aInputBuffer : InputBuffer | aTransmitter.inputs)]
      package body [aInputBuffer.name/] is
         use Agent_[anAgent.name/]_Buffers.transmitters.[aTransmitter.name/].inputs.[aInputBuffer.name/];
         procedure Send(item : in Data_Type) is
         begin
            SharedInputDataBuffers.Send_[bufferId(aInputBuffer)/](item);
         end Send;         
      end [aInputBuffer.name/];
      [/for]
   end [aTransmitter.name/];
   [/for]
end transmitters;
[else]
--  there are no RCI to forward for the transmitter inputs
[/if]
[/template]

[template public agent_body(anAgent : Agent)]
	
[comment @main /]
[file ('agent_'+anAgent.name+'.adb', false, 'UTF-8')]
-- with Ada.Text_IO;
with Agent_[anAgent.name/]_Buffers; use Agent_[anAgent.name/]_Buffers;
with Agent_[anAgent.name/]_Behaviors; use Agent_[anAgent.name/]_Behaviors;

package body Agent_[anAgent.name/] is

   [InputDataBuffers()/]

   task Main;

   [AgentTaskMainBody()/]

   [AgentRCI()/]
end Agent_[anAgent.name/];
[/file]
	
[/template]
